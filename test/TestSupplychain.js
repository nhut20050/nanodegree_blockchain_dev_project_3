// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require('SupplyChain')


contract('SupplyChain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    var     sku                     =   1;
    var     upc                     =   1;
    const   ownerID                 =   accounts[0];
    const   originFarmerID          =   accounts[1];
    const   originFarmName          =   "John Doe";
    const   originFarmInformation   =   "Yarray Valley";
    const   originFarmLatitude      =   "-38.239770";
    const   originFarmLongitude     =   "144.341490";
    var     productID               =   sku + upc;
    const   productNotes            =   "Best beans for Espresso";
    const   productPrice            =   web3.utils.toWei("1", "ether");
    var     itemState               =   0;
    const   distributorID           =   accounts[2];
    const   retailerID              =   accounts[3];
    const   consumerID              =   accounts[4];
    const   emptyAddress            =   '0x0000000000000000000000000000000000000000';
    const   State                   =   {
                                            Harvested:  0,
                                            Processed:  1,
                                            Packed:     2,
                                            ForSale:    3,
                                            Sold:       4,
                                            Shipped:    5,
                                            Received:   6,
                                            Purchased:  7
                                        };

    ///Available Accounts
    ///==================
    ///(0) 0x4893702260020C39f30aA991d17d589bb235e41f
    ///(1) 0x5EE5E7a4afcb566324850065E445DF41dBfFc439
    ///(2) 0xf992eF7ebA1E6BE4Bb449cA86357D5ec07d1cbc9
    ///(3) 0xC5C063f2839ab5e6Cc0eF3BF7b1d4cdB21ee0Bc1
    ///(4) 0xEB1F74b19E8f3fcd5C59e0D44522b1183aC32059
    ///(5) 0xfCfe92c41F58e081a850e3afF7B6067521612bf5
    ///(6) 0xFc72915eA4749F52453954243F761827D20780Ff
    ///(7) 0xBBB3D2eb34D7eE134E8f84CE9b7eC2b263d49835
    ///(8) 0x9488f55d84AC2944494c15344a9DA703283B4bcD
    ///(9) 0x41605d5d0A0C9919f0851cc75bb336175e36210F

    console.log("ganache-cli accounts used here..." );
    console.log("Contract Owner: accounts[0] ",     accounts[0]);
    console.log("Farmer: accounts[1] ",             accounts[1]);
    console.log("Distributor: accounts[2] ",        accounts[2]);
    console.log("Retailer: accounts[3] ",           accounts[3]);
    console.log("Consumer: accounts[4] ",           accounts[4]);

    // Instead of init the same variables in each test.
    // Create a global to use for each test.
    var supplyChain;
    var eventEmitted = false;

    before(async () => {
        supplyChain = await SupplyChain.deployed();
        await supplyChain.addFarmer         (originFarmerID,    {from: ownerID});
        await supplyChain.addDistributor    (distributorID,     {from: ownerID});
        await supplyChain.addRetailer       (retailerID,        {from: ownerID});
        await supplyChain.addConsumer       (consumerID,        {from: ownerID});
    });

    function emitted_event_handler(err, res){
        eventEmitted = true;
    }

    function assert_emitted_event(){
        assert.equal(eventEmitted, true, "Emitted event is invalid.");
    }

    async function assert_buffer_result_one(expected_state){
        // Get result
        const result_buffer_one = await supplyChain.fetchItemBufferOne(upc);

        // Verify the result set
        assert.equal(result_buffer_one[0], sku, 'Error: Invalid item SKU');
        assert.equal(result_buffer_one[1], upc, 'Error: Invalid item UPC');
        assert.equal(result_buffer_one[2], get_expected_item_owner(expected_state), 'Error: Missing or Invalid ownerID');
        assert.equal(result_buffer_one[3], originFarmerID, 'Error: Missing or Invalid originFarmerID');
        assert.equal(result_buffer_one[4], originFarmName, 'Error: Missing or Invalid originFarmName');
        assert.equal(result_buffer_one[5], originFarmInformation, 'Error: Missing or Invalid originFarmInformation');
        assert.equal(result_buffer_one[6], originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude');
        assert.equal(result_buffer_one[7], originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude');
    }

    async function assert_buffer_result_two(expected_state){
        // Get result
        const result_buffer_two = await supplyChain.fetchItemBufferTwo(upc);

        // Verify the result set
        assert.equal(result_buffer_two[0], sku, 'Error: Invalid item SKU');
        assert.equal(result_buffer_two[1], upc, 'Error: Invalid item UPC');
        assert.equal(result_buffer_two[2], productID, 'Error: Missing or Invalid productID');
        assert.equal(result_buffer_two[3], productNotes, 'Error: Missing or Invalid productNotes');
        assert.equal(result_buffer_two[4], (expected_state >= State.ForSale) ? productPrice : 0, 'Error: Missing or Invalid productPrice');
        assert.equal(result_buffer_two[5], expected_state, 'Error: invalid item State');
        assert.equal(result_buffer_two[6], (expected_state >= State.Sold) ? distributorID : emptyAddress, 'Error: Missing or Invalid distributorID');
        assert.equal(result_buffer_two[7], (expected_state >= State.Received) ? retailerID : emptyAddress, 'Error: Missing or Invalid retailerID');
        assert.equal(result_buffer_two[8], (expected_state >= State.Purchased) ? consumerID : emptyAddress, 'Error: Missing or Invalid consumerID');
    }

    function get_expected_item_owner(expected_state){
        switch (expected_state){
            case State.Harvested:
            case State.Processed:
            case State.Packed:
            case State.ForSale:
                return originFarmerID;
            case State.Sold:
            case State.Shipped:
                return distributorID;
            case State.Received:
                return retailerID;
            case State.Purchased:
                return consumerID;
        }
    }

    async function assert_emitted_event_and_result(expected_state){
        assert_emitted_event();
        await assert_buffer_result_one(expected_state);
        await assert_buffer_result_two(expected_state);
    }

    // 1st Test
    it("Testing smart contract function harvestItem() that allows a farmer to harvest coffee", async() => {
        await supplyChain.Harvested(emitted_event_handler);

        // Harvest coffee action
        await supplyChain.harvestItem(
            upc,
            originFarmerID,
            originFarmName,
            originFarmInformation,
            originFarmLatitude,
            originFarmLongitude,
            productNotes,
            {
                from: originFarmerID
            }
        );

        // Check if state is Harvested
        await assert_emitted_event_and_result(State.Harvested);

    })

    // 2nd Test
    it("Testing smart contract function processItem() that allows a farmer to process coffee", async() => {
        await supplyChain.Processed(emitted_event_handler);

        await supplyChain.processItem(
            upc,
            {
                from: originFarmerID
            }
        );
        
        await assert_emitted_event_and_result(State.Processed);
    })

    // 3rd Test
    it("Testing smart contract function packItem() that allows a farmer to pack coffee", async() => {
        await supplyChain.Packed(emitted_event_handler);

        await supplyChain.packItem(
            upc,
            {
                from: originFarmerID
            }
        );
        
        await assert_emitted_event_and_result(State.Packed);
    })

    // 4th Test
    it("Testing smart contract function sellItem() that allows a farmer to sell coffee", async() => {
        await supplyChain.ForSale(emitted_event_handler);

        await supplyChain.sellItem(
            upc,
            productPrice,
            {
                from: originFarmerID
            }
        );
        
        await assert_emitted_event_and_result(State.ForSale);
    })

    // 5th Test
    it("Testing smart contract function buyItem() that allows a distributor to buy coffee", async() => {
        await supplyChain.Sold(emitted_event_handler);

        await supplyChain.buyItem(
            upc,
            {
                from: distributorID,
                value: productPrice
            }
        );
        
        await assert_emitted_event_and_result(State.Sold);
    })

    // 6th Test
    it("Testing smart contract function shipItem() that allows a distributor to ship coffee", async() => {
        await supplyChain.Shipped(emitted_event_handler);

        await supplyChain.shipItem(
            upc,
            {
                from: distributorID
            }
        );
        
        await assert_emitted_event_and_result(State.Shipped);
    })

    // 7th Test
    it("Testing smart contract function receiveItem() that allows a retailer to mark coffee received", async() => {
        await supplyChain.Received(emitted_event_handler);

        await supplyChain.receiveItem(
            upc,
            {
                from: retailerID
            }
        );
        
        await assert_emitted_event_and_result(State.Received);
    })    

    // 8th Test
    it("Testing smart contract function purchaseItem() that allows a consumer to purchase coffee", async() => {
        await supplyChain.Purchased(emitted_event_handler);

        await supplyChain.purchaseItem(
            upc,
            {
                from: consumerID
            }
        );
        
        await assert_emitted_event_and_result(State.Purchased);
    })    

    // 9th Test
    it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async() => {
        await assert_buffer_result_one(State.Purchased);
    })

    // 10th Test
    it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async() => {
        await assert_buffer_result_two(State.Purchased);
    })

});

